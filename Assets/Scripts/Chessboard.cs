using UnityEngine;

public class Chessboard : MonoBehaviour
{
    [Header("Art stuff")]
    [SerializeField] private Material tileMaterial;
    [SerializeField] private float tileSize = 0.2f;
    [SerializeField] private float yOffset = 0.2f;
    [SerializeField] private Vector3 boardCenter = new Vector3();


    [Header("Prefabs & Materials")]
    [SerializeField] private GameObject[] prefabs;
    [SerializeField] private Material[] teamMaterials;

    //LOGIC
    private const int TILE_COUNT_X = 8;
    private const int TILE_COUNT_Y = 8;
    private GameObject[,] tiles;
    private Camera currentCamera;
    private Vector2Int currentHover;
    private Vector3 bounds;

    // Start is called before the first frame update
    void Start()
    {
        tileSize = 0.721f;
        yOffset = 0.01f;
        generateAllTiles(tileSize, TILE_COUNT_X, TILE_COUNT_Y); 
    }
    void Update()
    {
        if (!currentCamera)
        {
            currentCamera = Camera.main;
            return;
        }

        RaycastHit info;
        Ray ray = currentCamera.ScreenPointToRay(Input.mousePosition);
        
        //Raycast sends out a ray from origin (which is currently generated by
        //mouse on a screen point, which itself is hooked to a camera.
        //info stores data about where the closest collider was hit
        //100 is arbitrary length of the ray that is cast, long rays take more computation
        //LayerMask filters out all objects that are hit that are not called "Tile"
        if (Physics.Raycast(ray, out info, 100, LayerMask.GetMask("Tile", "Hover")))
        {
            //transform is the position of the rigidbody collider that was hit.
            //Get the indexes (x,y) of the tile that was hit with mouse generated ray
            Vector2Int hitPosition = LookupTileIndex(info.transform.gameObject);


            //If hovering after not hovering any tile:
            if (currentHover == -Vector2Int.one)
            {
                currentHover = hitPosition; //Assign the hovered tile to class variable

                //Since hitPosition is a Vector2Int of a tile's location then we can
                //take the tile that was hit and change it's layer
                tiles[hitPosition.x, hitPosition.y].layer = LayerMask.NameToLayer("Hover");
            }

            //If we were already hovering a tile and now it's another tile:
            else if (currentHover != hitPosition)
            {
                //Change the previous tile's layer back to type "Tile"
                tiles[currentHover.x, currentHover.y].layer = LayerMask.NameToLayer("Tile");
                
                currentHover = hitPosition; //Assign the hovered tile to class variable
                //Since hitPosition is a Vector2Int of a tile's location then we can
                //take the tile that was hit and change it's layer
                tiles[hitPosition.x, hitPosition.y].layer = LayerMask.NameToLayer("Hover");
            }
        }
        
        //If the ray gets nothing and therefore we are outside the board:
        else
        {
            //If the previous frame was on a tile, but now we are casting rays into empty space:
            if (currentHover != -Vector2Int.one)
            {
                //Change the previous tile's layer back to type "Tile"
                tiles[currentHover.x, currentHover.y].layer = LayerMask.NameToLayer("Tile");
                currentHover = -Vector2Int.one;
            }
        }
    }

    //Generate the board
    private void generateAllTiles(float tileSize, int tileCountX, int tileCountY)
    {
        yOffset += transform.position.y;
        bounds = new Vector3(tileCountX / 2 * tileSize, 0, (tileCountX / 2 * tileSize)) + boardCenter;

        tiles = new GameObject[tileCountX, tileCountY];
        for (int x = 0; x < tileCountX; x++)
        {
            for (int y = 0; y < tileCountY; y++)
            {
                tiles[x, y] = generateSingleTile(tileSize, x, y);
            }
        }
    }

    private GameObject generateSingleTile(float tileSize, int x, int y)
    {
        GameObject tileObject = new GameObject(string.Format("X:{0}, Y:{1}", x, y));
        //Connects tile to Chessboard class
        tileObject.transform.parent = transform;

        Mesh mesh = new Mesh();
        tileObject.AddComponent<MeshFilter>().mesh = mesh;
        tileObject.AddComponent<MeshRenderer>().material = tileMaterial;

        //Tile vertice locations, spawn them slightly above chessboard 
        Vector3[] vertices = new Vector3[4];
        vertices[0] = new Vector3(x * tileSize, yOffset, y * tileSize) - bounds;
        vertices[1] = new Vector3(x * tileSize, yOffset, (y+1) * tileSize) - bounds;
        vertices[2] = new Vector3((x+1) * tileSize, yOffset, y * tileSize) - bounds;
        vertices[3] = new Vector3((x + 1) * tileSize, yOffset, (y + 1) * tileSize) - bounds;

        //How triangles are made for mesh. In pairs of 3 attempts to make a triangle
        //according to the vertice indexes
        int[] tris = new int[] { 0, 1, 2, 1, 3, 2 };

        mesh.vertices = vertices;
        mesh.triangles = tris;
        //mesh.RecalculateNormals();

        tileObject.layer = LayerMask.NameToLayer("Tile");

        tileObject.AddComponent<BoxCollider>();
        return tileObject;
    }

    //Operations
    private Vector2Int LookupTileIndex(GameObject hitInfo)
    {
        for (int x = 0; x < TILE_COUNT_X; x++)
        {
            for (int y = 0; y < TILE_COUNT_Y; y++)
            {
                if (tiles[x, y] == hitInfo)
                {
                    return new Vector2Int(x, y);
                }
            }
        }
        return -Vector2Int.one; //This should not happen ever.
    }

}
